2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-897240716)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1419946672)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-897240716)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,774457819)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cisat :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cisat)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cjjjr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cjjjr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$chjip :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chjip)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjbca :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjbca)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciguq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciguq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$chvtl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$chvtl)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjjhd :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjjhd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckfhg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckfhg)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$chsqq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chsqq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjuji :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjuji)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciuxz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciuxz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cihtr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cihtr)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjrf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjrf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clhrr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhrr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$civin :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$civin)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckwmr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckwmr)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjvvf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjvvf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjkbm :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbm)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjvw :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjvw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clkro :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciqgl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciqgl)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckycv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckycv)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjssz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjssz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjeus :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjeus)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqfrl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqfrl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dqove :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqove)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dpmvr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpmvr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqkjv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqkjv)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dpzpx :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dpzpx)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dptpz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dptpz)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqzby :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqzby)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$driyb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$driyb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqhgb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqhgb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dreio :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dreio)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqssn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dqssn)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqnfe :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqnfe)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjwyu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjwyu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckrun :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrun)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cihww :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cihww)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckhxp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckhxp)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjjvp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjjvp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ciwik :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciwik)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1615518517)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckbqk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckbqk)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckwfk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwfk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cimjj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cimjj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckmqg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmqg)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjoiq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoiq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjbsq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbsq)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjyqf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjyqf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cktlo :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cktlo)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cijpy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijpy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckjre :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjre)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjlmq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjlmq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ciykc :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciykc)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,-2097001952)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cmcrs :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cmcrs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cnawj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cnawj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckhwz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ckhwz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cmpdk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cmpdk)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cllxp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cllxp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckwoa :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckwoa)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drujz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drujz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dsdvy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsdvy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drewa :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drewa)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drzbh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drzbh)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drony :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drony)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drjuf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drjuf)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drltq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drltq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$druxu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$druxu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqopb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqopb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drqob :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drqob)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drelv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drelv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqxim :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqxim)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
