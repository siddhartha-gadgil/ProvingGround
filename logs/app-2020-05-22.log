2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-897240716)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1419946672)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-897240716)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,774457819)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cisat :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cisat)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cjjjr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cjjjr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$chjip :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chjip)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjbca :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjbca)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciguq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciguq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$chvtl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$chvtl)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjjhd :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjjhd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckfhg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckfhg)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$chsqq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chsqq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjuji :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjuji)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciuxz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciuxz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cihtr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cihtr)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjrf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjrf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clhrr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhrr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$civin :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$civin)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckwmr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckwmr)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjvvf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjvvf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjkbm :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbm)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjvw :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjvw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clkro :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciqgl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciqgl)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckycv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckycv)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjssz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjssz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjeus :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjeus)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqfrl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqfrl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dqove :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqove)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dpmvr :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpmvr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqkjv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqkjv)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dpzpx :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dpzpx)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dptpz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dptpz)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqzby :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqzby)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$driyb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$driyb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqhgb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqhgb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dreio :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dreio)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqssn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dqssn)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqnfe :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqnfe)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjwyu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjwyu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckrun :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrun)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cihww :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cihww)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckhxp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckhxp)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjjvp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjjvp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ciwik :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciwik)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1615518517)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckbqk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckbqk)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckwfk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwfk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cimjj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cimjj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckmqg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmqg)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjoiq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoiq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjbsq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbsq)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjyqf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjyqf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cktlo :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cktlo)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cijpy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijpy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckjre :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjre)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjlmq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjlmq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ciykc :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciykc)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,-2097001952)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cmcrs :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cmcrs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cnawj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cnawj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckhwz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ckhwz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cmpdk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cmpdk)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cllxp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cllxp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckwoa :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckwoa)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drujz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drujz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dsdvy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsdvy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drewa :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drewa)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drzbh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drzbh)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drony :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drony)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drjuf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drjuf)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drltq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drltq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$druxu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$druxu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqopb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqopb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drqob :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drqob)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drelv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drelv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqxim :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqxim)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjztp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjztp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckrrq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrrq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciskq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciskq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckjht :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjht)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjoqo :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoqo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjefl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjefl)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1615518517)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckaff :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckaff)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckwtf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwtf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cijzn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijzn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckmeu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmeu)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjmcf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjmcf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ciyvs :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciyvs)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1299211175)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjqnf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjqnf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$ckmtn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckmtn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciaul :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciaul)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckbvy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckbvy)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjcxj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjcxj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cipib :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cipib)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjll :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjll)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clhgh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhgh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciryz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciryz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckurx :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckurx)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjwpq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjwpq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjhxq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjhxq)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,1838221781)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dqabl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqabl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dqicz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqicz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dpftq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpftq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqehb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqehb)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dputu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dputu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dpopg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dpopg)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,61122141)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$druaj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$druaj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dsglf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsglf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqygj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqygj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dsaqy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dsaqy)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drmvl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drmvl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drfyg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drfyg)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-1947019198)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (20,-567661294)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,-841318884)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,1591302876)
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,2073475022)
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (25,-1023996419)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1122475947)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-1218353307)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,634599903)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (31,-1767243359)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,1528679509)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,508716104)
2020.05.22 17:50:21 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckaeb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckaeb)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cksqz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cksqz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cioxc :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cioxc)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckjsl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjsl)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjnsm :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjnsm)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjbwu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbwu)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1615518517)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckngl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckngl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cljga :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cljga)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cithn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cithn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckynt :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckynt)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjydd :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjydd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjjjn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjjjn)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cllte :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cllte)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cmiro :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cmiro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjucb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cjucb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$clxnm :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clxnm)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckxct :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckxct)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjij :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckjij)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,1299211175)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckqor :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckqor)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clotk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clotk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$citvh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$citvh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$clctt :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clctt)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckaoz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckaoz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjkzy :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkzy)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dspda :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dspda)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dsymh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsymh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drwnk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drwnk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dstzb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dstzb)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dsilv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dsilv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dscnp :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dscnp)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drrah :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drrah)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dsaca :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsaca)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dqyep :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqyep)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drvuk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drvuk)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$drlbq :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drlbq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$drezj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drezj)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-789544750)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,-1645551407)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,2040525956)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,-1800305335)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (25,-599115809)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (26,-635849561)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-2020288530)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1871900621)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,700937163)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-2133912413)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1108485285)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-383201582)
2020.05.22 17:55:46 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Success: Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) â†’ ((M) â†’ (ð’° _0)) : 0.2857142857142857, (M) â†’ ((M) â†’ (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) â†’ ((M) â†’ (M)) : 0.047619047619047616, (M) â†’ ((M) â†’ (ð’° _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1299211175)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckpfo :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckpfo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clkmu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkmu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ciywv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciywv)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$clajj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clajj)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckblz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckblz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjood :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjood)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,-2097001952)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckjge :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjge)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clfzf :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clfzf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cioxn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cioxn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckutc :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckutc)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjuuo :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjuuo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjgeb :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjgeb)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$ckkxu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckkxu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$clghd :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clghd)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$citza :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$citza)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckvur :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckvur)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjxgh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjxgh)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cjkbz :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbz)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$clfxg :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$clfxg)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$cmcnn :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cmcnn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$cjqyv :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cjqyv)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$clquk :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clquk)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$ckrvs :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckrvs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$cketl :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cketl)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1838221781)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dtrzj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dtrzj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dtzru :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dtzru)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dtbez :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dtbez)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dtvxj :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dtvxj)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dtmom :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dtmom)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dthbu :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dthbu)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) â†’ ((M) â†’ (M)) : 0.26666666666666666, (M) â†’ ((M) â†’ (ð’° _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dtjkm :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dtjkm)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs)), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) â†’ (((eqM) (`b)) (`a)))) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(mul âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(mul âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(M âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€(M âˆˆ Typs)), (Pâ‚((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (ð’° _0)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(eqM âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(eqM âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(a)(e_r))(a)} âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(eqM) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(eqM) âˆˆ Funcs)), (Pâ‚((`$dtsqs :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dtsqs)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((mul) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(e_r âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs) =) (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((mul) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)})), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{(eqM(a)(b) \to eqM(b)(a))} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypOpt)}) =) Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs) =) (Pâ‚((mul) (e_r) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(axiom_{eqM(a)(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(a)(a)} âˆˆ Terms)), (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (`a)) (`a)) âˆˆ Typs)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dsrsx :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dsrsx)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((mul) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (Pâ‚€(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Typs) =) (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(TypOpt)})), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) âˆˆ Typs)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((M) â†’ ((M) â†’ (M)) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((M) â†’ ((M) â†’ (M)) âˆˆ Typs)), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(Wrap(mul) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(mul) âˆˆ Funcs)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dtnwh :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dtnwh)) ((axiom_{eqM(a)(a)}) (e_l))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms) =) (Coeff(Init(Terms))) * (Pâ‚€(axiom_{eqM(mul(e_l)(a))(a)} âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies), (Pâ‚((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs) =) (Coeff(Init(Typs))) * (Pâ‚€((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) â†’ ((((eqM) (`b)) (`c)) â†’ (((eqM) (`a)) (`c)))))) âˆˆ Typs)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((`$dtdqw :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dtdqw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs) =) (Pâ‚((eqM) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(TypFamilyOpt)}) =) Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies), (Pâ‚(Wrap(eqM) âˆˆ TypFamilies) =) (Coeff(Init(TypFamilies))) * (Pâ‚€(Wrap(eqM) âˆˆ TypFamilies)), (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) âˆˆ Funcs), (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs) =) (Coeff(Init(Funcs))) * (Pâ‚€(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs)), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) âˆˆ Terms)), (Pâ‚((mul) (e_r) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(Wrap((mul) (e_l)) âˆˆ Funcs) =) (Pâ‚((mul) (e_l) âˆˆ Terms)) / (Pâ‚({Terms âˆˆ Restrict(FuncOpt)})), (Pâ‚((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap(eqM) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚(((eqM) (e_l)) (e_r) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((mul) (e_r)) âˆˆ Funcs), (Pâ‚(((eqM) (e_l)) (e_l) âˆˆ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (Pâ‚(Wrap((eqM) (e_l)) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((mul) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(mul) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((`$dsyab :  M) â†¦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dsyab)) ((axiom_{eqM(a)(a)}) (e_r))) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) âˆˆ Funcs), (Pâ‚((eqM) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) âˆˆ Funcs))) * (Pâ‚(e_r âˆˆ Terms)), (Pâ‚({Terms âˆˆ Restrict(FuncOpt)}) =) Pâ‚(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) âˆˆ Funcs), (Pâ‚((axiom_{eqM(a)(a)}) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (Pâ‚(Wrap(axiom_{eqM(a)(a)}) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ Terms)), (Pâ‚((eqM) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (Pâ‚(Wrap(eqM) âˆˆ Funcs))) * (Pâ‚(e_l âˆˆ AtCoord(TermsWithTyp,M :: HNil))), (Pâ‚((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) âˆˆ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (Pâ‚(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) âˆˆ Funcs))) * (Pâ‚((axiom_{eqM(a)(a)}) (e_r) âˆˆ Terms)), (Pâ‚(((eqM) (e_r)) (e_l) âˆˆ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (Pâ‚(Wrap((eqM) (e_r)) âˆˆ TypFamilies))) * (Pâ‚(e_l âˆˆ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:50 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (19,-882146633)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (20,1943774896)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-1058594355)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,1544283379)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,-1699185398)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,282002186)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1556203222)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,-1019977704)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1534969617)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1853727301)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,1530413512)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,-1352424661)
2020.05.22 18:00:53 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Success: Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))
