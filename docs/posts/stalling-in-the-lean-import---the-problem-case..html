
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ProvingGround</title>
    <link rel="icon" href="../IIScLogo.jpg">

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
   <link href="../css/katex.min.css" rel="stylesheet">
   <link href="../css/main.css" rel="stylesheet">


    <link rel="stylesheet" href="../css/zenburn.css">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

   <script src="../js/ace.js"></script>
   <script src="../js/katex.min.js"></script>

    
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
  inlineMath: [ ['$', '$'] ],
  displayMath: [ ['$$', '$$']],
  processEscapes: true,
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
},
messageStyle: "none",
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
       </script>
    
  </head>

   
<body>
<nav class="navbar navbar-default">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">ProvingGround</span>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav" id="left-nav">
            <li><a href="../index.html">Docs Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Tutorials (notes)<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="../tuts/hott.html">HoTT</a></li><li><a href="../tuts/left-and-right-identities.html">Left and Right Identities</a></li><li><a href="../tuts/internal-repetition-for-length-functions.html">Internal repetition for length functions</a></li><li><a href="../tuts/inductive-types-(old-style).html">Inductive Types (old style)</a></li><li><a href="../tuts/inductive-types.html">Inductive Types</a></li><li><a href="../tuts/scalarep.html">ScalaRep</a></li><li><a href="../tuts/symbolic-algebra.html">Symbolic algebra</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Posts<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="../posts/computer-assistance-in-homogenous-length-functions.html">2018-1-14-Computer assistance in Homogenous length functions</a></li><li><a href="../posts/tuning-with-tensorflow.html">2017-12-12-Tuning with Tensorflow</a></li><li><a href="../posts/stalling-in-the-lean-import---the-problem-case..html">2017-12-7-Stalling in the lean import - the problem case.</a></li><li><a href="../posts/lean-import-and-propositions.html">2017-12-6-Lean Import and Propositions</a></li><li><a href="../posts/levels-of-parsimony,-as-seen-from-logic-runs.html">2017-11-2-Levels of parsimony, as seen from Logic runs</a></li><li><a href="../posts/improvements-to-searching-and--exploration.html">2017-10-31-Improvements to searching and  exploration</a></li><li><a href="../posts/logic-and-modus-ponens.html">2017-10-25-Logic and Modus Ponens</a></li><li><a href="../posts/prover-components-and-identities-in-a-monoid.html">2017-10-20-Prover Components and Identities in a Monoid</a></li><li><a href="../posts/on-import-from-lean-export-format.html">2017-10-17-On import from Lean Export format</a></li><li><a href="../posts/&quot;quasi-literate-programming&quot;.html">2014-12-31-&quot;Quasi-literate programming&quot;</a></li>
              </ul>
            </li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li> <a href="../scaladoc/provingground/index.html" target="_blank">ScalaDocs</a></li>
            <li> <a href="https://github.com/siddhartha-gadgil/ProvingGround" target="_blank">
              <img src="../GitHub-Mark-Light-32px.png" alt="Github"></img> </a> </li>



          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
<div class="container">
<h1 class="text-center">Stalling in the lean import - the problem case.</h1>

<div class="text-justify">
<h2>The setup within lean</h2>
<p>By working through the lean import in steps, I pinned down the function application that causes stuff to stall. Extracting inductive definitions from lean is quite clean. Here is the code for extracting the argument <code>x</code>. Before posting, I should also extract the function <code>f</code>. Below they are ddenoted <code>ff</code> and <code>xx</code></p>
<pre><code class="language-scala">import trepplein._
import interface._, LeanInterface._
val mods = getMods(&quot;data/group.export&quot;)
val parser = new LeanParser(mods)
import monix.execution.Scheduler.Implicits.global
val fG = parser.parse(Const(&quot;group&quot;, Vector()), Vector()).runAsync

val fgmul = parser.parse(Const(Name(&quot;group&quot;, &quot;mul&quot;), Vector()), Vector()).runAsync

// val fgone = parser.parse(Const(Name(&quot;group&quot;, &quot;one&quot;), Vector()), Vector()).runAsync // not necessary

// val fgmass = parser.parse(Const(Name(&quot;group&quot;, &quot;mul_assoc&quot;), Vector()), Vector()).runAsync // may not be needed

// val fgmone = parser.parse(Const(Name(&quot;group&quot;, &quot;mul_one&quot;), Vector()), Vector()).runAsync // this is the one that causes a crash

val A = &quot;A&quot; :: Type

import Fold._

val semigroupIndMod = parser.termIndModMap(Name(&quot;semigroup&quot;))
val semigroup = parser.defnMap(Name(&quot;semigroup&quot;))
val semigroupMk = parser.defnMap(Name(&quot;semigroup&quot;, &quot;mk&quot;))

val groupMul = parser.defnMap(Name(&quot;group&quot;, &quot;mul&quot;))
val group = parser.defnMap(Name(&quot;group&quot;))

val gp = &quot;group(A)&quot; :: toTyp(group(A))
val wit = &quot;_&quot; :: domain(semigroupMk(A)(groupMul(A)(gp)))
val xx = semigroupMk(A)(groupMul(A)(gp))(wit)
</code></pre>
<p>Indeed, we can define <code>ff</code> with</p>
<pre><code class="language-scala">@ val ff = parser.defnMap(Name(&quot;semigroup&quot;, &quot;to_has_mul&quot;))(A)
</code></pre>
<p>Some extra code, for building from <code>rec</code> more directly:</p>
<pre><code class="language-scala">val groupIndMod = parser.termIndModMap(Name(&quot;group&quot;))
val groupIndA = groupIndMod.asInstanceOf[SimpleIndMod].getInd(Vector(A))
groupIndA.getInd(Vector(A -&gt;: A -&gt;: A))

val gr = groupIndA.recE(A -&gt;: A -&gt;: A)

val m = &quot;m&quot; :: A -&gt;: A -&gt;: A
</code></pre>
<h3>More direct definitions</h3>
<p>For the record, here are the inductive definitions</p>
<pre><code class="language-scala">@ semigroupIndA
res168: ConstructorSeqTL[_1.SS, Term, _1.Intros] = ConstructorSeqTL(
  Cons(
    (semigroup.mk : ($aoe : ğ’° _0 ~&gt; $aoi : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0))) ~&gt; ($aoj : ($aoe : ğ’° _0) ~&gt; $aok : ($aoe : ğ’° _0) ~&gt; $aol : ($aoe : ğ’° _0) ~&gt; (((eq : ($j : ğ’° _0 ~&gt; ($j : ğ’° _0) â†’ (($j : ğ’° _0) â†’ (Prop)))) ($aoe : ğ’° _0) : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ (Prop)))) ((($aoi : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0)))) ((($aoi : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0)))) ($aoj : ($aoe : ğ’° _0)) : (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0))) ($aok : ($aoe : ğ’° _0)) : ($aoe : ğ’° _0)) : (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0))) ($aol : ($aoe : ğ’° _0)) : ($aoe : ğ’° _0)) : (($aoe : ğ’° _0) â†’ (Prop))) ((($aoi : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0)))) ($aoj : ($aoe : ğ’° _0)) : (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0))) ((($aoi : (($aoe : ğ’° _0) â†’ (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0)))) ($aok : ($aoe : ğ’° _0)) : (($aoe : ğ’° _0) â†’ ($aoe : ğ’° _0))) ($aol : ($aoe : ğ’° _0)) : ($aoe : ğ’° _0)) : ($aoe : ğ’° _0))) â†’ ((semigroup : ((ğ’° _0) â†’ (ğ’° _0))) ($aoe : ğ’° _0) : ğ’° _0))) (A : ğ’° _0),
    CnstDepFuncConsShape(
      (A â†’ (A â†’ A)),
      provingground.induction.ConstructorShape$$Lambda$7658/1930236645@1c8ae6b1
    ),
    Empty()
  ),
  semigroup(A)
)

@ groupIndA
res169: ConstructorSeqTL[_1.SS, Term, _1.Intros] = ConstructorSeqTL(
  Cons(
    (group.mk : ($b : ğ’° _0 ~&gt; $f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ~&gt; ($g : ($b : ğ’° _0) ~&gt; $h : ($b : ğ’° _0) ~&gt; $i : ($b : ğ’° _0) ~&gt; (((eq : ($j : ğ’° _0 ~&gt; ($j : ğ’° _0) â†’ (($j : ğ’° _0) â†’ (Prop)))) ($b : ğ’° _0) : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ (Prop)))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ($g : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($h : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($i : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ (Prop))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ($g : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ($h : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($i : ($b : ğ’° _0)) : ($b : ğ’° _0)) : ($b : ğ’° _0))) â†’ ($anq : ($b : ğ’° _0) ~&gt; ($anr : ($b : ğ’° _0) ~&gt; (((eq : ($j : ğ’° _0 ~&gt; ($j : ğ’° _0) â†’ (($j : ğ’° _0) â†’ (Prop)))) ($b : ğ’° _0) : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ (Prop)))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ($anq : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($anr : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ (Prop))) ($anr : ($b : ğ’° _0))) â†’ (($dtzv : ($b : ğ’° _0) ~&gt; (((eq : ($j : ğ’° _0 ~&gt; ($j : ğ’° _0) â†’ (($j : ğ’° _0) â†’ (Prop)))) ($b : ğ’° _0) : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ (Prop)))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) ($dtzv : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($anq : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ (Prop))) ($dtzv : ($b : ğ’° _0))) â†’ ($fmtc : (($b : ğ’° _0) â†’ ($b : ğ’° _0)) ~&gt; ($fmtd : ($b : ğ’° _0) ~&gt; (((eq : ($j : ğ’° _0 ~&gt; ($j : ğ’° _0) â†’ (($j : ğ’° _0) â†’ (Prop)))) ($b : ğ’° _0) : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ (Prop)))) ((($f : (($b : ğ’° _0) â†’ (($b : ğ’° _0) â†’ ($b : ğ’° _0)))) (($fmtc : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($fmtd : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ ($b : ğ’° _0))) ($fmtd : ($b : ğ’° _0)) : ($b : ğ’° _0)) : (($b : ğ’° _0) â†’ (Prop))) ($anq : ($b : ğ’° _0))) â†’ ((group : ((ğ’° _0) â†’ (ğ’° _0))) ($b : ğ’° _0) : ğ’° _0)))))) (A : ğ’° _0),
    CnstDepFuncConsShape(
      (A â†’ (A â†’ A)),
      provingground.induction.ConstructorShape$$Lambda$7658/1930236645@5f38386d
    ),
    Empty()
  ),
  group(A)
)
</code></pre>
<p>A more readable form is to just look at the types.</p>
<pre><code class="language-scala">@ semigroupMk(A).typ
res173: Typ[U] = âˆ($aoi : (A â†’ (A â†’ A))){ (âˆ($aoj : A){ âˆ($aok : A){ âˆ($aol : A){ eq(A)($aoi($aoi($aoj)($aok))($aol))($aoi($aoj)($aoi($aok)($aol))) } } } â†’ semigroup(A)) }

@ groupMk(A).typ
res174: Typ[U] = âˆ($f : (A â†’ (A â†’ A))){ (âˆ($g : A){ âˆ($h : A){ âˆ($i : A){ eq(A)($f($f($g)($h))($i))($f($g)($f($h)($i))) } } } â†’ âˆ($anq : A){ (âˆ($anr : A){ eq(A)($f($anq)($anr))($anr) } â†’ (âˆ($dtzv : A){ eq(A)($f($dtzv)($anq))($dtzv) } â†’ âˆ($fmtc : (A â†’ A)){ (âˆ($fmtd : A){ eq(A)($f($fmtc($fmtd))($fmtd))($anq) } â†’ group(A)) })) }) }
</code></pre>
<h2>The culprit: Equality</h2>
<p>When the equality from lean is replaced by a formal one, the result parses. We setup</p>
<pre><code class="language-scala">@ val eqA = &quot;eql(A)&quot; :: A -&gt;: A -&gt;: Prop
eqA: Func[Term, Func[Term, Typ[Term]]] with Subs[Func[Term, Func[Term, Typ[Term]]]] = eql(A)

@ val eql = parser.defnMap(Name(&quot;eq&quot;))
eql: Term = eq
</code></pre>
<p>We can then get</p>
<pre><code class="language-scala">@ val xxx = xx.replace(eql(A), eqA)
xxx: Term with Subs[Term] = semigroup.mk(A)(rec(group(A))((A â†’ (A â†’ A)))(($exahig : (A â†’ (A â†’ A))) â†¦ ($exaigb : âˆ($exahih : A){ âˆ($exahii : A){ âˆ($exahij : A){ eql(A)($exahig($exahig($exahih)($exahii))($exahij))($exahig($exahih)($exahig($exahii)($exahij))) } } }) â†¦ ($exaigc : A) â†¦ ($excazi : âˆ($exaigd : A){ eql(A)($exahig($exaigc)($exaigd))($exaigd) }) â†¦ ($exdtso : âˆ($excazj : A){ eql(A)($exahig($excazj)($exaigc))($excazj) }) â†¦ ($exdtsq : (A â†’ A)) â†¦ ($faopho : âˆ($exdtsr : A){ eql(A)($exahig($exdtsq($exdtsr))($exdtsr))($exaigc) }) â†¦ $exahig)(group(A)))(_)

@ val fff = ff.replace(eql(A), eqA)
fff: Term with Subs[Term] = ($btj : semigroup(A)) â†¦ has_mul.mk(A)(rec(semigroup(A))((A â†’ (A â†’ A)))(($btt : (A â†’ (A â†’ A))) â†¦ ($cro : âˆ($btu : A){ âˆ($btv : A){ âˆ($btw : A){ eql(A)($btt($btt($btu)($btv))($btw))($btt($btu)($btt($btv)($btw))) } } }) â†¦ $btt)($btj))

@ fff(xxx)
res182: Term = has_mul.mk(A)(rec(semigroup(A))((A â†’ (A â†’ A)))(($btt : (A â†’ (A â†’ A))) â†¦ ($cro : âˆ($btu : A){ âˆ($btv : A){ âˆ($btw : A){ eql(A)($btt($btt($btu)($btv))($btw))($btt($btu)($btt($btv)($btw))) } } }) â†¦ $btt)(semigroup.mk(A)(rec(group(A))((A â†’ (A â†’ A)))(($exahig : (A â†’ (A â†’ A))) â†¦ ($exaigb : âˆ($exahih : A){ âˆ($exahii : A){ âˆ($exahij : A){ eql(A)($exahig($exahig($exahih)($exahii))($exahij))($exahig($exahih)($exahig($exahii)($exahij))) } } }) â†¦ ($exaigc : A) â†¦ ($excazi : âˆ($exaigd : A){ eql(A)($exahig($exaigc)($exaigd))($exaigd) }) â†¦ ($exdtso : âˆ($excazj : A){ eql(A)($exahig($excazj)($exaigc))($excazj) }) â†¦ ($exdtsq : (A â†’ A)) â†¦ ($faopho : âˆ($exdtsr : A){ eql(A)($exahig($exdtsq($exdtsr))($exdtsr))($exaigc) }) â†¦ $exahig)(group(A)))(_)))

@ fff(xxx).typ
res189: Typ[U] = has_mul(A)
</code></pre>


</div>
</div>

<div class="container-fluid">
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer navbar-fixed-bottom bg-primary">
    <h4>
    &nbsp;Developed by:
    &nbsp;<a href="http://math.iisc.ac.in/~gadgil" target="_blank">&nbsp; Siddhartha Gadgil</a>

  </h4>

  </div>
</div>
<script type="text/javascript" src="../js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="../js/bootstrap.min.js"></script>
<script type="text/javascript" src="../js/provingground.js"></script>
<script>
  provingground.main()
</script>
   
</body>
</html>
   